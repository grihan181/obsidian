- [[#Serial Garbage Collector]]
- [[#Parallel Garbage Collector (Throughput Collector)]]
- [[#Concurrent Mark-Sweep (CMS) Collector]]
- [[#G1 Garbage Collector]]
- [[#Z Garbage Collector (ZGC) и Shenandoah]]
### Serial Garbage Collector
Serial GC работает в однопоточном режиме, что означает, что во время сборки мусора все другие потоки приложения приостанавливаются (Stop-The-World пауза). Это самый простой и базовый сборщик мусора в JVM, без дополнительных сложностей многопоточной обработки или параллельной сборки мусора.

Когда Serial GC начинает процесс сборки мусора, он останавливает все другие потоки в приложении. Это означает, что выполнение приложения полностью приостанавливается на время сборки мусора.

Serial GC начинает с процесса маркировки, который определяет, какие объекты в куче все еще используются и должны быть сохранены. Он обходит все объекты, доступные из корневого набора ([root set](https://www.ibm.com/docs/en/ztpf/2020?topic=collector-root-set)), который включает в себя глобальные переменные, активные потоки и т.д., маркируя каждый достижимый объект.

После маркировки GC удаляет все немаркированные объекты, освобождая занимаемую ими память. Это процесс называется _очисткой_.

В некоторых случаях, особенно если в куче много фрагментированной памяти, Serial GC может выполнить уплотнение. Это процесс, в ходе которого оставшиеся объекты перемещаются в непрерывный блок, что уменьшает фрагментацию памяти и упрощает последующее выделение памяти.

Не смотря на свою простоту и эффективность в средах с ограниченными ресурсами, SGC имеет ряд существенных недостатков.

Stop-The-World паузы могут быть проблематичными для приложений, требующих высокой отзывчивости или непрерывной работы.

Не подходит для многопроцессорных или многопоточных приложений, где требуется более высокая пропускная способность

### Parallel Garbage Collector (Throughput Collector)
Parallel GC использует несколько потоков для выполнения задач GC, что позволяет эффективно использовать многопроцессорные системы. Основная цель - максимизация пропускной способности приложения, то есть максимальное количество работы, которое приложение может выполнить за единицу времени.

Как и Serial GC, Parallel GC также инициирует Stop-The-World паузы. Во время этих пауз все потоки приложения приостанавливаются для выполнения задач GC.

В этой фазе GC идентифицирует все живые объекты в куче. Это достигается путём обхода всех объектов, начиная с корневого набора (который включает в себя глобальные переменные и активные потоки). Многопоточность используется для ускорения процесса обхода и маркировки.

После того как "живые" объекты определены, GC удаляет недоступные объекты, тем самым освобождая память. Эта фаза также может выполняться многопоточно для ускорения процесса.

В некоторых случаях может проводиться уплотнение памяти для уменьшения фрагментации. Это включает перемещение живых объектов так, чтобы они занимали непрерывный блок памяти. Уплотнение улучшает последующее выделение памяти, но может увеличить время паузы GC.

PGC позволяет нам добиться улучшенной производительности на многопроцессорных и многопоточных системах. Но не смотря на это возможны более длительные Stop-The-World паузы по сравнению с более специализированными сборщиками мусора.

Резюмируя - не всегда идеален для приложений, где критично время отклика.
### Concurrent Mark-Sweep (CMS) Collector
CMS спроектирован для выполнения большей части своих задач одновременно с работой приложения, что минимизирует паузы, связанные с GC. Работа CMS делится на две основные фазы: фазу маркировки (Marking Phase) и фазу очистки (Sweeping Phase).

**Фаза предварительной очистки (Initial Mark):**

Это короткая Stop-The-World пауза, во время которой CMS маркирует корневые объекты, то есть объекты, доступные непосредственно из потоков приложения, глобальных переменных и т.д. Эта фаза быстра, но требует остановки всех потоков приложения.

**Конкурентная фаза маркировки (Concurrent Marking):**

В этой фазе, CMS продолжает процесс маркировки, обходя все объекты, достижимые из корневых объектов. Эта работа выполняется параллельно с выполнением приложения. Во время этой фазы приложение продолжает работать, что снижает влияние GC на время отклика приложения.

**Фаза перемаркировки (Remark):**

Это ещё одна короткая Stop-The-World пауза, во время которой CMS исправляет любые изменения, сделанные в куче после начала фазы конкурентной маркировки. Для оптимизации этого процесса часто используется алгоритм "снимка" (Snapshot-At-The-Beginning), который отслеживает изменения, произошедшие в куче с момента начала маркировки.

**Конкурентная фаза очистки (Concurrent Sweeping):**

После завершения маркировки, CMS удаляет немаркированные, а значит, недоступные объекты. Этот процесс также происходит параллельно с выполнением приложения. В результате, освобождается память, занимаемая недоступными объектами.

CMS обычно выбирают для серверных приложений и приложений в реальном времени, где важнее минимизировать время остановки, чем максимизировать пропускную способность или оптимизировать использование памяти. Однако, следует учитывать нагрузку на процессор и потенциальные проблемы с фрагментацией памяти, которая может быть из-за отсутствия уплотнения по умолчанию.
### G1 Garbage Collector

G1 (Garbage-First) Garbage Collecto отличается от традиционных подходов, таких как CMS или Parallel GC, своей способностью более эффективно управлять системными ресурсами.

G1 GC разделяет кучу на множество небольших областей (регионов), что позволяет более гибко управлять памятью. Эти регионы могут быть различных типов, включая _Eden_, _Survivor_, и _Old_. G1 GC приоритизирует сборку мусора в тех регионах, где это наиболее эффективно, основываясь на объеме мусора и затратах на его очистку.

Как и в CMS, G1 начинается с короткой Stop-The-World паузы для маркировки корневых объектов. Это включает в себя объекты, которые непосредственно доступны из потоков приложения, статические объекты и т.д.

G1 продолжает процесс маркировки, обходя все объекты, доступные из корневых объектов, параллельно с выполнением приложения. В это время приложение продолжает работать, что снижает влияние GC на время отклика.

Далее идет фаза _Final Mark,_ включает еще одну короткую Stop-The-World паузу, во время которой G1 завершает процесс маркировки. В эту фазу включается обработка изменений, которые произошли в куче с момента начала конкурентной маркировки.

В последней фазе (сборке мусора) G1 собирает мусор из отдельных регионов. Это может включать перемещение живых объектов из одного региона в другой. Эта фаза также является Stop-The-World паузой, но ее длительность более предсказуема и обычно короче, чем в традиционных GC.

G1 Garbage Collector подходит для приложений с большим объемом кучи, где важны как производительность, так и предсказуемое время остановки. Он идеально подходит к примеру для серверных приложений.
### Z Garbage Collector (ZGC) и Shenandoah

Z Garbage Collector (ZGC) и Shenandoah предназначены для минимизации Stop-The-World (STW) пауз, что является маст хевом для приложений с требованиями к низкой задержке.

#### ZGC

ZGC разделяет кучу на набор мелких регионов. Это позволяет собирать мусор в каждом регионе независимо, что уменьшает время STW пауз. ZGC начинается с конкурентной фазы маркировки, которая происходит параллельно с работой приложения, минимизируя задержки.

Одной из ключевых особенностей ZGC является его способность к конкурентной релокации объектов. Это означает, что он может перемещать объекты во время работы приложения, что снижает необходимость в длительных STW паузах.

ZGC эффективно управляет фрагментацией памяти, регулярно уплотняя кучу во время работы приложения. ZGC использует цветные указатели и специальные барьеры чтения/записи для отслеживания доступных и перемещенных объектов, что позволяет оптимизировать процесс сборки мусора.

#### Shenandoah

Аналогично ZGC, Shenandoah выполняет большую часть работы по маркировке и компактизации конкурентно, то есть параллельно с выполнением приложения.

Shenandoah стремится минимизировать STW паузы, необходимые для некоторых задач сборки мусора. Shenandoah использует барьеры на пути выполнения для отслеживания доступа к объектам и их перемещения, что позволяет приложению продолжать работу во время сборки мусора.

Как и ZGC, Shenandoah активно управляет фрагментацией в куче, регулярно уплотняя пространство для эффективного выделения памяти.

Оба GC разработаны для обеспечения низких задержек в приложениях с большой кучей.

Подготовил небольшую обзорную табличку сравнения сборщиков:

| Сборщик Мусора |                                                   Преимущества | Недостатки                                              | Идеален для                                       |
| :------------- | -------------------------------------------------------------: | ------------------------------------------------------- | ------------------------------------------------- |
| Serial GC      |                   Простота, эффективность для малых приложений | Низкая производительность на многопроцессорных системах | Малые приложения, ограниченные ресурсы            |
| Parallel GC    |                                 Высокая пропускная способность | Длинные паузы GC                                        | Серверные приложения, многопроцессорные системы   |
| CMS            |                                                Низкие паузы GC | Возможная фрагментация памяти, сложность                | Интерактивные приложения                          |
| G1 GC          | Баланс между производительностью и задержкой, масштабируемость | Может требовать тонкой настройки                        | Большие серверные приложения                      |
| ZGC/Shenandoah |                                              Минимальные паузы | Новизна, потенциальные ограничения в использовании      | Приложения с требованиями к ультранизкой задержке |
