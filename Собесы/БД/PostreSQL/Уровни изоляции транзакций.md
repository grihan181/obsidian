- `Read uncommitted` — чтение незафиксированных данных. Могут происходить грязные чтения, неповторяемые чтения, фантомные чтения и потерянное обновление. [[#Read uncommitted]]
- `Read committed` — чтение зафиксированных данных. Грязные чтения предотвращены, но могут возникать неповторяющиеся чтения, фантомные чтения и потерянное обновление. [[#Read committed]]
- `Repeatable read` — повторяющееся чтение. Грязные чтения, неповторяющиеся чтения и потерянное обновление предотвращены, но могут возникать фантомные чтения. [[#Repeatable read]]
- `Serializable` — упорядочиваемость. Транзакции полностью изолированы. Исключено влияние одной транзакции на другую в момент выполнения.

Свойство Isolation в ACID гласит: Во время выполнения транзакции другие транзакции не должны оказывать влияние на результат. Но изолированность транзакций обходится дорого, поэтому в базах данных существуют режимы, которые не полностью изолируют транзакцию от других. Однако, это приводит к неприятным последствиям, таким как:

- **«Грязное» чтение.** В результатах запроса появляются промежуточные результаты параллельной транзакции, которая ещё не завершилась.
- **Потерянное обновление.** Две параллельные транзакции меняют одни и те же данные. Итоговый результат обновления предсказать невозможно.
- **Неповторяющееся чтение.** Запрос с одними и теми же условиями даёт неодинаковые результаты в рамках транзакции.
- **Фантомное чтение.** В результатах повторяющегося запроса появляются и исчезают строки, которые модифицирует параллельная транзакция.

![[trans_isol.jpg]]

Примеры:
### **Read uncommitted**
**«Грязное» чтение** (dirty reads) — в результатах запроса появляются промежуточные результаты параллельной транзакции, которая ещё не завершилась.

*Эта проблема наблюдается при уровне изоляции `READ_UNCOMMITTED`.*

Эта проблема наблюдается при уровне изоляции `READ_UNCOMMITTED`.

Рассмотрим на примере. У нас будет два параллельных потока. В первом мы открываем транзакцию и устанавливаем новый баланс первому пользователю равным 100_000. Но транзакцию не коммитим. Вместо этого, запускаем вторую параллельную транзакцию в отдельном потоке, а текущий поток засыпает на 2 секунды.

Во второй транзакции считывается баланс пользователя из БД и выводится в консоль. Значение баланса будет 100_000, несмотря на то, что первая транзакция ещё не закоммитила свои изменения.

Но дальше самое интересное, мы выполняем rollback первой транзакции, и баланс пользователя снова становится 1000. То есть вторая транзакция работала с не валидными данными.
### **Read committed**
№1
**Потерянное обновление** (lost update) — две параллельные транзакции меняют одни и те же данные, при этом итоговый результат обновления предсказать невозможно.

*Эта проблема присутствует на уровне изоляции `READ_COMMITTED` и ниже.*

Обе транзакции получают баланс первого пользователя. Напомню, что баланс равен 1000.

Выполняется обновление баланса пользователя первой транзакцией. Для этого к полученному ранее балансу прибавляется 10. Но сейчас эти изменения не были отправлены в БД. Это произойдёт только при закрытии транзакции.

Закрываем первую транзакцию. Баланс пользователя в БД равен 1010. Но вторая транзакция идёт параллельно, и ничего не знает об изменении баланса пользователя. Ведь баланс мы уже считали из БД, и там было 1000.

Вторая транзакция прибавляет к балансу пользователя 5. После чего вторая транзакция также закрывается. Баланс пользователя в БД равен 1005. Мы потеряли обновления, которые выполнила первая транзакция.

№2
**Неповторяющееся чтение** (non-repeatable reads) — запрос с одними и теми же условиями даёт неодинаковые результаты в рамках транзакции.

*Эта проблема присутствует на уровне изоляции `READ_COMMITTED` и ниже.*

Рассмотрим пример. Начинаем первую транзакцию. Считываем баланс пользователя, получаем значение 1000. Далее стартует вторая транзакция в отдельном потоке, а текущий поток засыпает.

Во второй транзакции устанавливаем пользователю баланс равный 100_000. После чего закрываем вторую транзакцию. Баланс успешно обновился в БД.

Первая транзакция продолжает выполнение. Снова запрашивает баланс пользователя из БД, на этот раз получает значение 100_000. Таким образом, вторая транзакция повлияла на выполнение первой.

### **Repeatable read**
**Фантомное чтение** (phantom reads) — в результатах повторяющегося запроса появляются и исчезают строки, которые в данный момент модифицирует параллельная транзакция.

*Эта проблема присутствует на уровне изоляции `REPEATABLE_READ` и ниже.*

Рассмотрим пример. Открываем первую транзакцию. Запрашиваем количество строк в таблице пользователей, получаем ответ 2. Далее стартуем вторую транзакцию, а поток с первой транзакцией засыпает. Вторая транзакция добавляет новую запись в таблицу пользователей и коммитит изменения. После этого первая транзакция продолжается. Снова запрашиваем количество строк, получаем на этот раз ответ 3.

В PostgreSQL на уровне `REPEATABLE_READ` также предотвращены фантомные чтения.