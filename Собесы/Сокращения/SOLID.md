- [[#1. Single responsibility principle, принцип единственной ответственности|Single responsibility principle (принцип единственной ответственности)]].
- [[#2. Open-closed principle, принцип открытости/закрытости|Open-closed principle (принцип открытости/закрытости)]].
- [[#3. Liskov substitution principle, принцип подстановки Лисков|Liskov substitution principle (принцип подстановки Лисков).]]
- [[#4. Interface segregation principle, принцип разделения интерфейса|Interface segregation principle (принцип разделения интерфейса).]]
- [[#5. Dependency inversion principle, принцип инверсии зависимостей|Dependency inversion principle (принцип инверсии зависимостей).]]
### 1. Single responsibility principle, принцип единственной ответственности

Он говорит о том, что каждая ваша функция должна выполнять только одну задачу.

Чтобы иметь только одну ответственность, функции должны быть простыми. Если же нужно более сложное поведение, придётся объединять вводы и выводы нескольких функций и делать композицию.

И хоть я и говорю сейчас о функциях, принцип SRP применим практически ко всему. Взять, например, архитектуру какой-нибудь платформы. Её гораздо проще обслуживать и развивать, если вместо мегамодуля, ответственного вообще за всё, у вас будет несколько микросервисов, каждый из которых отвечает за свою маленькую задачу. Но — ещё раз — то же касается и функций: более простые и понятные функции легче поддерживать, читать, понимать и даже просто писать.

Например, если вам нужна функция `getUserAndRelatedBooks`, в которой прописана логика двух задач, подумайте о том, чтобы разбить её на две функции: `getUser` и `getUsersBooks`, где вторая будет получать на вход результат выполнения первой. Так вы сможете изящно реализовать `getUserAndRelatedBooks`, просто указав `getUsersBooks (getUser)`, то есть объединив их в композицию.
### 2. Open-closed principle, принцип открытости/закрытости
Он говорит о том, что ваши модули или библиотеки (в зависимости от того, как экспортируется код) должны быть открыты для расширения (например, расширения поведения), но закрыты для модификации (ибо ни у кого нет желания возиться с чужим модулем).

### 3. Liskov substitution principle, принцип подстановки Лисков
Наследующий класс должен дополнять, а не замещать поведение базового класса.

### 4. Interface segregation principle, принцип разделения интерфейса
Он говорит о том, что нельзя заставлять программистов, работающих с вашим кодом, использовать ненужные методы. Ведь интерфейс — это всего лишь взаимодействие классов (набор методов, которые необходимо реализовать). Поэтому при создании интерфейсов  убедитесь, что методы, которые требуется реализовать, действительно нужны вашим пользователям, — и не городите в одном интерфейсе кучу функциональности. Разделяйте и властвуйте.

### 5. Dependency inversion principle, принцип инверсии зависимостей
**Формулировка:**  
A. Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.  
B. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.